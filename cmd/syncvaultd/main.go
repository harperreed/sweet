// ABOUTME: SyncVaultd is the server backend for SyncVault, providing encrypted data sync.
// ABOUTME: Handles PocketBase JWT auth, multi-device sync, and account management.

package main

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/tools/router"

	pbclient "suitesync/internal/pocketbase"

	_ "suitesync/cmd/syncvaultd/migrations" // Import migrations
)

// Server bundles state for syncvaultd handlers.
type Server struct {
	app          core.App
	pbClient     pbclient.Client
	limiters     *rateLimiterStore // Per-user rate limiting for authenticated endpoints
	authLimiters *rateLimiterStore // Per-IP rate limiting for auth endpoints
}

func main() {
	app := pocketbase.New()

	// Initialize PocketBase client for external PB instance (if configured)
	pbClient := initPocketBaseClient()

	// Create single server instance for routes and cleanup
	srv := &Server{
		app:          app,
		pbClient:     pbClient,
		limiters:     newRateLimiterStore(DefaultRateLimitConfig()),
		authLimiters: newRateLimiterStore(AuthRateLimitConfig()),
	}

	// Register custom routes
	app.OnServe().BindFunc(func(se *core.ServeEvent) error {
		srv.registerRoutes(se.Router)
		return se.Next()
	})

	if err := app.Start(); err != nil {
		log.Fatal(err)
	}
}

func (s *Server) registerRoutes(r *router.Router[*core.RequestEvent]) {
	r.GET("/healthz", func(e *core.RequestEvent) error {
		return e.NoContent(http.StatusOK)
	})

	// Health endpoint for clients (returns JSON with server time)
	r.GET("/v1/health", s.wrapHandler(s.handleHealth))

	// Auth endpoints (with IP-based rate limiting)
	r.POST("/v1/auth/pb/register", s.wrapHandler(s.withIPRateLimit(s.handlePBRegister)))
	r.POST("/v1/auth/pb/login", s.wrapHandler(s.withIPRateLimit(s.handlePBLogin)))
	r.POST("/v1/auth/pb/refresh", s.wrapHandler(s.withIPRateLimit(s.handlePBRefresh)))

	// Sync endpoints (protected)
	r.POST("/v1/sync/push", s.wrapHandler(s.withAuth(s.handlePush)))
	r.GET("/v1/sync/pull", s.wrapHandler(s.withAuth(s.handlePull)))
	r.POST("/v1/sync/snapshot", s.wrapHandler(s.withAuth(s.handleSnapshot)))
	r.POST("/v1/sync/compact", s.wrapHandler(s.withAuth(s.handleCompact)))

	// Device management (protected)
	r.GET("/v1/devices", s.wrapHandler(s.withAuth(s.handleListDevices)))
	r.DELETE("/v1/devices/:deviceId", s.wrapHandler(s.withAuth(s.handleRevokeDevice)))

	// Account management (protected)
	r.POST("/v1/account/migrate", s.wrapHandler(s.withAuth(s.handleMigrate)))
}

// wrapHandler converts http.HandlerFunc to PocketBase RequestHandler.
func (s *Server) wrapHandler(h http.HandlerFunc) func(*core.RequestEvent) error {
	return func(e *core.RequestEvent) error {
		h(e.Response, e.Request)
		return nil
	}
}

// withIPRateLimit applies per-IP rate limiting for auth endpoints.
// This protects against brute-force attacks on unauthenticated endpoints.
func (s *Server) withIPRateLimit(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if s.authLimiters != nil {
			clientIP := getClientIP(r)
			limiter := s.authLimiters.get(clientIP)
			if !limiter.Allow() {
				fail(w, http.StatusTooManyRequests, "rate limit exceeded")
				return
			}
		}
		next(w, r)
	}
}

// auth middleware

type ctxUserIDKey struct{}
type ctxDeviceIDKey struct{}

type authInfo struct {
	userID   string
	deviceID string
}

func (s *Server) withAuth(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		info, err := s.authUser(r)
		if err != nil {
			fail(w, http.StatusUnauthorized, err.Error())
			return
		}

		// Rate limit check
		if s.limiters != nil {
			limiter := s.limiters.get(info.userID)
			if !limiter.Allow() {
				fail(w, http.StatusTooManyRequests, "rate limit exceeded")
				return
			}
		}

		ctx := context.WithValue(r.Context(), ctxUserIDKey{}, info.userID)
		ctx = context.WithValue(ctx, ctxDeviceIDKey{}, info.deviceID)
		next(w, r.WithContext(ctx))
	}
}

func (s *Server) authUser(r *http.Request) (authInfo, error) {
	h := r.Header.Get("Authorization")
	if h == "" || !strings.HasPrefix(h, "Bearer ") {
		return authInfo{}, errors.New("missing bearer token")
	}
	raw := strings.TrimSpace(strings.TrimPrefix(h, "Bearer "))
	if raw == "" {
		return authInfo{}, errors.New("missing bearer token")
	}

	// Use JWT auth (PocketBase)
	return s.authUserJWT(raw)
}

func (s *Server) authUserJWT(token string) (authInfo, error) {
	// Use PocketBase's built-in token verification
	// This works for auth tokens generated by NewAuthToken() or NewStaticAuthToken()
	userRecord, err := s.app.FindAuthRecordByToken(token, core.TokenTypeAuth)
	if err != nil {
		return authInfo{}, errors.New("invalid token")
	}

	// JWT tokens don't have device_id - use empty string
	return authInfo{
		userID:   userRecord.Id,
		deviceID: "",
	}, nil
}

// push/pull

type pushReq struct {
	UserID   string     `json:"user_id"`
	DeviceID string     `json:"device_id"`
	Changes  []pushItem `json:"changes"`
}

type pushItem struct {
	ChangeID string   `json:"change_id"`
	Entity   string   `json:"entity"`
	TS       int64    `json:"ts"`
	Env      envelope `json:"env"`
	DeviceID string   `json:"device_id,omitempty"` // Optional per-item device_id (overrides request-level)
}

type envelope struct {
	NonceB64 string `json:"nonce_b64"`
	CTB64    string `json:"ct_b64"`
}

type pushResp struct {
	AckChangeIDs []string `json:"ack_change_ids"`
}

func (s *Server) handlePush(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		fail(w, http.StatusMethodNotAllowed, "method not allowed")
		return
	}
	authUser := r.Context().Value(ctxUserIDKey{}).(string)

	req, err := decodePushRequest(r)
	if err != nil {
		fail(w, http.StatusBadRequest, err.Error())
		return
	}
	if req.UserID != authUser {
		fail(w, http.StatusForbidden, "token user mismatch")
		return
	}

	ack, err := s.insertChanges(r.Context(), req)
	if err != nil {
		fail(w, http.StatusInternalServerError, err.Error())
		return
	}

	ok(w, pushResp{AckChangeIDs: ack})
}

func decodePushRequest(r *http.Request) (pushReq, error) {
	var req pushReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return pushReq{}, errors.New("invalid json")
	}
	req.UserID = strings.TrimSpace(req.UserID)
	req.DeviceID = strings.TrimSpace(req.DeviceID)
	if req.UserID == "" || req.DeviceID == "" {
		return pushReq{}, errors.New("user_id and device_id required")
	}
	return req, nil
}

func (s *Server) insertChanges(ctx context.Context, req pushReq) ([]string, error) {
	ack := make([]string, 0, len(req.Changes))
	for _, it := range req.Changes {
		if it.ChangeID == "" || it.Entity == "" || it.Env.NonceB64 == "" || it.Env.CTB64 == "" {
			continue
		}

		ts := it.TS
		if ts == 0 {
			ts = time.Now().Unix()
		}
		// Use per-item device_id if provided, otherwise fall back to request-level device_id
		deviceID := it.DeviceID
		if deviceID == "" {
			deviceID = req.DeviceID
		}

		// Insert change within transaction to prevent seq race condition
		err := s.app.RunInTransaction(func(txApp core.App) error {
			changesCol, err := txApp.FindCollectionByNameOrId("sync_changes")
			if err != nil {
				return errors.New("collection not found")
			}

			// Check if change already exists (idempotency)
			_, err = txApp.FindFirstRecordByFilter(changesCol, "user_id = {:user_id} && change_id = {:change_id}",
				map[string]any{"user_id": req.UserID, "change_id": it.ChangeID})
			if err == nil {
				// Already exists, skip (will be acked outside transaction)
				return nil
			}

			// Get next seq number within transaction
			seq, err := getNextSeqTx(txApp, changesCol, req.UserID)
			if err != nil {
				return err
			}

			changeRecord := core.NewRecord(changesCol)
			changeRecord.Set("seq", seq)
			changeRecord.Set("user_id", req.UserID)
			changeRecord.Set("change_id", it.ChangeID)
			changeRecord.Set("device_id", deviceID)
			changeRecord.Set("entity", it.Entity)
			changeRecord.Set("ts", ts)
			changeRecord.Set("nonce_b64", it.Env.NonceB64)
			changeRecord.Set("ct_b64", it.Env.CTB64)
			return txApp.Save(changeRecord)
		})
		if err != nil {
			return nil, errors.New("db error")
		}
		ack = append(ack, it.ChangeID)
	}

	if len(ack) > 0 {
		if err := s.pbClient.IncrementUsage(ctx, req.UserID, len(ack)); err != nil {
			log.Printf("pocketbase usage update failed: %v", err)
		}
	}
	return ack, nil
}

// getNextSeqTx returns the next sequence number within a transaction.
// This ensures atomic read-and-increment to prevent race conditions.
//
//nolint:unparam // Error return kept for API consistency; may be used in future.
func getNextSeqTx(txApp core.App, changesCol *core.Collection, userID string) (int64, error) {
	// Find max seq for this user
	records, err := txApp.FindRecordsByFilter(changesCol, "user_id = {:user_id}", "-seq", 1, 0, map[string]any{"user_id": userID})
	if err != nil {
		// If query fails, start at 1 (safe default for new users)
		return 1, nil //nolint:nilerr // Starting at seq 1 is safe even on query error.
	}
	if len(records) == 0 {
		return 1, nil
	}
	return int64(records[0].GetInt("seq")) + 1, nil
}

type pullResp struct {
	Items    []pullItem    `json:"items"`
	Snapshot *snapshotInfo `json:"snapshot,omitempty"`
}

type pullItem struct {
	Seq      int64    `json:"seq"`
	ChangeID string   `json:"change_id"`
	DeviceID string   `json:"device_id"`
	Entity   string   `json:"entity"`
	Env      envelope `json:"env"`
	TS       int64    `json:"ts"`
}

func (s *Server) handlePull(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		fail(w, http.StatusMethodNotAllowed, "method not allowed")
		return
	}
	authUser := r.Context().Value(ctxUserIDKey{}).(string)

	userID, since, entity, err := parsePullParams(r)
	if err != nil {
		fail(w, http.StatusBadRequest, err.Error())
		return
	}
	if userID != authUser {
		fail(w, http.StatusForbidden, "token user mismatch")
		return
	}

	resp, err := s.buildPullResponse(r.Context(), userID, since, entity)
	if err != nil {
		fail(w, http.StatusInternalServerError, err.Error())
		return
	}
	ok(w, resp)
}

func parsePullParams(r *http.Request) (userID string, since int64, entity string, err error) {
	userID = strings.TrimSpace(r.URL.Query().Get("user_id"))
	sinceStr := strings.TrimSpace(r.URL.Query().Get("since"))
	if userID == "" || sinceStr == "" {
		return "", 0, "", errors.New("user_id and since required")
	}
	since, err = strconv.ParseInt(sinceStr, 10, 64)
	if err != nil || since < 0 {
		return "", 0, "", errors.New("invalid since")
	}
	entity = strings.TrimSpace(r.URL.Query().Get("entity"))
	return userID, since, entity, nil
}

func (s *Server) buildPullResponse(ctx context.Context, userID string, since int64, entity string) (pullResp, error) {
	resp := pullResp{}

	// Include snapshot if pulling from 0 with entity specified
	if since == 0 && entity != "" {
		snapshot, err := s.getLatestSnapshot(ctx, userID, entity)
		if err == nil && snapshot != nil {
			resp.Snapshot = snapshot
			since = snapshot.MinSeq
		}
	}

	items, err := s.queryChanges(ctx, userID, since)
	if err != nil {
		return pullResp{}, err
	}
	resp.Items = items
	return resp, nil
}

//nolint:unparam // ctx reserved for future use (e.g., cancellation).
func (s *Server) queryChanges(_ context.Context, userID string, since int64) ([]pullItem, error) {
	changesCol, err := s.app.FindCollectionByNameOrId("sync_changes")
	if err != nil {
		return nil, err
	}

	records, err := s.app.FindRecordsByFilter(changesCol, "user_id = {:user_id} && seq > {:since}", "seq", 500, 0,
		map[string]any{"user_id": userID, "since": since})
	if err != nil {
		return nil, err
	}

	items := make([]pullItem, len(records))
	for i, r := range records {
		items[i] = pullItem{
			Seq:      int64(r.GetInt("seq")),
			ChangeID: r.GetString("change_id"),
			DeviceID: r.GetString("device_id"),
			Entity:   r.GetString("entity"),
			TS:       int64(r.GetInt("ts")),
			Env:      envelope{NonceB64: r.GetString("nonce_b64"), CTB64: r.GetString("ct_b64")},
		}
	}
	return items, nil
}

// handleHealth returns server health info for client connectivity checks.
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		fail(w, http.StatusMethodNotAllowed, "method not allowed")
		return
	}
	ok(w, map[string]any{
		"time": time.Now().Unix(),
	})
}

// helpers

func ok(w http.ResponseWriter, v any) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(v); err != nil {
		log.Printf("write response: %v", err)
	}
}

func fail(w http.ResponseWriter, code int, msg string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	if err := json.NewEncoder(w).Encode(map[string]any{"error": msg}); err != nil {
		log.Printf("write error response: %v", err)
	}
}

func initPocketBaseClient() pbclient.Client {
	base := strings.TrimSpace(os.Getenv("POCKETBASE_URL"))
	token := strings.TrimSpace(os.Getenv("POCKETBASE_ADMIN_TOKEN"))
	if base == "" || token == "" {
		return pbclient.NoopClient{}
	}
	return &pbclient.HTTPClient{
		BaseURL: base,
		Token:   token,
	}
}

func randHex(n int) string {
	b := make([]byte, n)
	_, _ = rand.Read(b)
	return hex.EncodeToString(b)
}

// snapshotInfo is used by pull endpoint to return snapshot data.
type snapshotInfo struct {
	SnapshotID string   `json:"snapshot_id"`
	MinSeq     int64    `json:"min_seq"`
	CreatedAt  int64    `json:"created_at"`
	Env        envelope `json:"env"`
}
